"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const config_1 = require("hardhat/config");
const abigen_1 = require("./abigen");
(0, config_1.task)("testgen-config", "Generate testgen configuration files")
    .addFlag("fixture", "Include a shared fixture")
    .addOptionalParam("path", "Output path for config file (default: testgen)")
    .addOptionalParam("filename", "Name of config file")
    .addOptionalVariadicPositionalParam("contracts", "Contracts to include into one configuration file")
    .setAction(async (params, hre) => {
    await hre.run("compile");
    const javascript = !hre.config.paths.configFile.endsWith(".ts");
    let { out = "testgen", contracts = [], fixture = false, filename, } = params;
    if (!filename) {
        if (contracts.length == 1) {
            filename = `config.${contracts[0].toLowerCase()}.${javascript ? "js" : "ts"}`;
        }
        else {
            filename = `config.${javascript ? "js" : "ts"}`;
        }
    }
    const filePath = path_1.default.join(hre.config.paths.root, out, filename);
    const { contractNames, contractFnNames } = await (0, abigen_1.abiData)();
    const sequencesByContract = {};
    let contractIdentifiers = [];
    for (const [contractName, contractKeys] of Object.entries(contractNames)) {
        for (const contractKey of contractKeys) {
            const contractIdentifier = contractKeys.length == 1 ? contractName : contractKey;
            contractIdentifiers.push(contractIdentifier);
            sequencesByContract[contractIdentifier] = [];
            //        sequencesByContract[contractIdentifier].push({ abi: `${contractIdentifier}.*` })
            for (const [abiIdentifier, abi] of Object.entries(contractFnNames[contractKey])) {
                if (!abi)
                    continue;
                if (abi.stateMutability == "view")
                    continue;
                if (abi.stateMutability == "pure")
                    continue;
                if (["fallback", "constructor"].includes(abi.type))
                    continue;
                const signature = `${contractIdentifier}.${abiIdentifier}`;
                sequencesByContract[contractIdentifier].push({ abi: signature });
            }
            sequencesByContract[contractIdentifier].sort((a, b) => a.abi.localeCompare(b.abi));
        }
    }
    contractIdentifiers.sort((a, b) => a.localeCompare(b));
    if (contracts?.length) {
        contractIdentifiers = contractIdentifiers.filter((c) => contracts.includes(c));
    }
    else {
        contractIdentifiers = contractIdentifiers.filter((c) => sequencesByContract[c].length);
    }
    let fileContent;
    if (javascript) {
        fileContent = `${fixture
            ? `
async function fixture() {
  const { ethers } = require('hardhat')
  const [admin, user1] = await ethers.getSigners()
}\n`
            : ""}
const config = {
  ${contractIdentifiers
            .map((contractIdentifier) => {
            return `"${contractIdentifier}": async ({ ethers }, [admin, user]) => {
    ${fixture ? "await fixture()\n" : ""}
    return [
      ${sequencesByContract[contractIdentifier]
                .map((s) => {
                return `["${s.abi}"]`;
            })
                .join(",\n      ")}
    ]
  }`;
        })
            .join(",\n  ")}
}

module.exports = config
`;
    }
    else {
        fileContent = `import { TestSuiteConfigs } from 'hardhat/types'
${fixture
            ? `
async function fixture() {
  const { ethers } = await import('hardhat')
  const [admin, user1] = await ethers.getSigners()
}\n`
            : ""}
const config: TestSuiteConfigs = {
  ${contractIdentifiers
            .map((contractIdentifier) => {
            return `"${contractIdentifier}": async ({ ethers }, [admin, user]) => {
    ${fixture ? "await fixture()\n" : ""}
    return [
      ${sequencesByContract[contractIdentifier]
                .map((s) => {
                return `["${s.abi}"]`;
            })
                .join(",\n      ")}
    ]
  }`;
        })
            .join(",\n  ")}
}

export default config
`;
    }
    fs_1.default.mkdirSync(path_1.default.dirname(filePath), { recursive: true });
    fs_1.default.writeFileSync(filePath, fileContent);
});
//# sourceMappingURL=configgen.js.map