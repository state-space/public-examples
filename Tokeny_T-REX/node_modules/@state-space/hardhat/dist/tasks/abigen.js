"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.abiData = abiData;
exports.abi = abi;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const task_names_1 = require("hardhat/builtin-tasks/task-names");
const config_1 = require("hardhat/config");
const testgen_1 = require("../testgen");
(0, config_1.task)(task_names_1.TASK_COMPILE).setAction(async (_params, hre, runSuper) => {
    await runSuper();
    // await hre.run("testgen-types");
});
(0, config_1.task)("testgen-types", "Generate typings for ABI sequences")
    .addOptionalParam("out", "Output path for typings file")
    .setAction(async (params, hre) => {
    const { out = "testgen/abi.d.ts" } = params;
    const { contractNames, contractFnNames } = await abiData();
    const abis = ["*"];
    const viewAbis = [];
    const contractIdentifiers = [];
    const abiFunctionSignatures = [];
    for (const [contractName, contractKeys] of Object.entries(contractNames)) {
        for (const contractKey of contractKeys) {
            const contractIdentifier = contractKeys.length == 1 ? contractName : contractKey;
            contractIdentifiers.push(contractIdentifier);
            abis.push(`${contractIdentifier}.*`);
            abis.push(`${contractIdentifier}.constructor`);
            abis.push(`${contractIdentifier}.new`);
            for (const [abiIdentifier, abi] of Object.entries(contractFnNames[contractKey])) {
                if (!abi)
                    continue;
                const signature = `${contractIdentifier}.${abiIdentifier}`;
                if (abi.stateMutability == "view") {
                    viewAbis.push(signature);
                }
                abis.push(signature);
                abiFunctionSignatures.push(`export function abi(signature: '${signature}'): ISequenceEntryBuilder<From, To, ${renderObj(constraintForAbi(abi))}>`);
            }
        }
    }
    const stringQuotedAbis = abis.sort().map((a) => `"${a}"`);
    const _stringQuotedViewAbis = viewAbis.sort().map((a) => `"${a}"`);
    const stringQuotedContractNames = contractIdentifiers
        .sort()
        .map((a) => `"${a}"`);
    const p = path_1.default.join(hre.config.paths.root, out);
    fs_1.default.mkdirSync(path_1.default.dirname(p), { recursive: true });
    fs_1.default.writeFileSync(p, `import "hardhat/types/config";
import { HardhatEthersSigner } from "@nomicfoundation/hardhat-ethers/signers"
import { HardhatRuntimeEnvironment } from "hardhat/types";
import { AddressLike } from "ethers";
import { ABIConstraintAddress, ABIConstraintArrayDynamic, ABIConstraintArray, ISequenceEntryBuilder, SequenceEntryBuilder, SequenceTransaction, Sequences, SuiteSettings } from "@state-space/hardhat";
declare module "hardhat/types/config" {
  export type FixtureFn = (
      hre: HardhatRuntimeEnvironment,
      accounts: HardhatEthersSigner[]
    ) => Promise<FixtureFnResult | FixtureFnResult["sequences"] | void>
  export type FixtureFnResult = {
    sequences?: Sequences<ABISignature | { abi: ABISignature; to?: To; from?: From } | SequenceEntryBuilder | SequenceTransaction>
    accountNames?: Record<string, Account>
  }
  export interface TestSuiteConfig {
    fixture?: FixtureFn
    sequences?: Sequences<
      ABISignature | { abi: ABISignature; to?: To; from?: From } | SequenceEntryBuilder
    >
    settings?: SuiteSettings
  }
  export type TestSuiteConfigs = Record<string, TestSuiteConfig | FixtureFn>
}
declare module "@state-space/hardhat" {
  export function abi(signature: ABISignature): SequenceEntryBuilder
  ${abiFunctionSignatures.join("\n  ")}
}
type From = string | number | AddressLike
type To = ContractName | AddressLike
type ContractName = ${stringQuotedContractNames.join("\n| ")} 
type ABISignature = ${stringQuotedAbis.join("\n| ")}
`);
});
async function abiData() {
    const hre = await Promise.resolve().then(() => __importStar(require("hardhat")));
    const contractNames = {};
    const contractFnNames = {};
    for (const contract of await hre.artifacts.getAllFullyQualifiedNames()) {
        const artifact = await hre.artifacts.readArtifact(contract);
        if (!artifact.abi.length || artifact.bytecode == "0x")
            continue;
        const [, name] = contract.split(":");
        if (!contractNames[contract]) {
            contractNames[name] = [contract];
        }
        else {
            contractNames[name].push(contract);
        }
        contractFnNames[contract] = {};
        for (const abi of artifact.abi) {
            switch (abi.type) {
                case "function":
                    contractFnNames[contract][signatureForAbi(abi)] = abi;
                    break;
                case "constructor":
                    contractFnNames[contract][signatureForAbi(abi)] = abi;
                    break;
                case "fallback":
                    contractFnNames[contract]["fallback"] = abi;
                    break;
                default:
            }
        }
    }
    return {
        contractNames,
        contractFnNames,
    };
}
function signatureForAbi(abi) {
    switch (abi.type) {
        case "function":
            return `${abi.name}(${abi.inputs?.map((input) => typeForAbi(input)).join(",")})`;
        case "constructor":
            return `constructor(${abi.inputs?.map((input) => typeForAbi(input)).join(",")})`;
        default:
            throw "unrecognized abi type";
    }
}
function typeForAbi(input) {
    if (input.components) {
        return input.type.replaceAll("tuple", `(${input.components.map((c) => typeForAbi(c)).join(",")})`);
    }
    return input.type;
}
function constraintForAbi(abi) {
    const constraint = {};
    for (const [index, input] of (abi.inputs || []).entries()) {
        constraint[`${input.name ? input.name : index}?`] =
            constraintForAbiInput(input);
    }
    return constraint;
}
const addressRegex = /^address$/;
const arrayDynamicRegex = /^(.+)\[]$/;
const arrayRegex = /^(.+)\[(\d+)]$/;
function constraintForAbiInput(abi) {
    let constraintType = {};
    switch (true) {
        case addressRegex.test(abi.type): {
            constraintType = `ABIConstraintAddress`;
            break;
        }
        case arrayRegex.test(abi.type): {
            const [, innerType] = abi.type.match(arrayRegex);
            constraintType = `ABIConstraintArray<${renderObj(constraintForAbiInput({
                type: innerType,
                name: "",
                components: abi.components,
            }))}>`;
            break;
        }
        case arrayDynamicRegex.test(abi.type): {
            const [, innerType] = abi.type.match(arrayDynamicRegex);
            constraintType = `ABIConstraintArrayDynamic<${renderObj(constraintForAbiInput({
                type: innerType,
                name: "",
                components: abi.components,
            }))}>`;
            break;
        }
        case abi.type == "tuple": {
            for (const cmp of abi.components ?? []) {
                constraintType[`${cmp.name}?`] = constraintForAbiInput(cmp);
            }
            break;
        }
        default:
            return "never";
    }
    return constraintType;
}
function renderObj(obj) {
    if (typeof obj == "string") {
        return obj;
    }
    const rendered = [];
    for (const [key, entry] of Object.entries(obj)) {
        rendered.push(`${key}: ${renderObj(entry)}`);
    }
    return "{" + rendered.join(",") + "}";
}
function abi(signature) {
    return new testgen_1.SequenceEntryBuilder(signature);
}
//# sourceMappingURL=abigen.js.map