import type { AddressLike, Addressable, BlockWithIndex, EIP1193Provider } from "./types";
export * from "./types";
export { authenticate } from "../util/auth";
export type Account = string | Promise<string> | Addressable;
export type To = Account;
export type From = Account | number;
export type ABIConstraintAddress = {
    addresses?: AddressLike[];
} | AddressLike[] | AddressLike;
export type ABIConstraintArray<Item = ABIConstraint> = {
    item?: Item;
};
export type ABIConstraintArrayDynamic<Item = ABIConstraint> = {
    lengths?: number[];
    item?: Item;
};
export type ABIConstraintStruct = Record<string, ABIConstraint>;
export interface IABIConstraintArray extends ABIConstraintArray {
}
export interface IABIConstraintArrayDynamic extends ABIConstraintArrayDynamic {
}
export interface IABIConstraintStruct extends ABIConstraintStruct {
}
export type ABIConstraint = ABIConstraintAddress | IABIConstraintArray | IABIConstraintArrayDynamic | IABIConstraintStruct;
export interface ISequenceEntryBuilder<F, T, C> {
    abi: string;
    _to?: To[];
    _from?: From[];
    _constraints?: ABIConstraintStruct;
    from: (...accountIndexOrAddress: F[]) => this;
    to: (...contract: T[]) => this;
    constrain: (constraints: C) => this;
    constraints: (constraints: C) => this;
}
export declare class SequenceEntryBuilder implements ISequenceEntryBuilder<From, To, ABIConstraintStruct> {
    abi: string;
    _to?: To[] | undefined;
    _from?: From[] | undefined;
    _constraints?: ABIConstraintStruct | undefined;
    constructor(abi: string, _to?: To[] | undefined, _from?: From[] | undefined, _constraints?: ABIConstraintStruct | undefined);
    from(...accountIndexOrAddress: From[]): this;
    to(...contract: To[]): this;
    constrain(constraints: ABIConstraintStruct): this;
    constraints(constraints: ABIConstraintStruct): this;
}
export type ABISignature = string;
export type SequenceEntryObject = {
    abi: ABISignature;
    to?: AddressLike;
    from?: number | AddressLike;
    constraints?: ABIConstraintStruct;
} | SequenceEntryTxObject;
export type SequenceEntryTxObject = {
    to?: string | null;
    from: string;
    input: string;
    value: number | string | bigint;
    number: string;
    timestamp: string;
};
export type Sequences<T> = (T | T[])[][];
export type NormalizedSequences<T> = T[][][];
export type NormalizedSequences2<T> = T[][];
export type SequenceEntry = ABISignature | SequenceEntryObject | SequenceEntryBuilder;
export type SequenceTransaction = () => Promise<any>;
export type OutputType = "hardhat/ethers6/ts" | "hardhat/ethers6/js" | "foundry";
export type DeterministicOption = "time" | "block-number";
export type SendProvider = {
    send: (method: string, params: any[] | undefined) => Promise<unknown>;
};
export declare const normalizeProvider: (someProvider: SendProvider | EIP1193Provider) => EIP1193Provider;
export declare function assertOutputType(outputType: never): never;
export declare function isABIConstraintAddress(c: ABIConstraint): c is ABIConstraintAddress;
export declare function isABIConstraintArrayDynamic(c: ABIConstraint): c is IABIConstraintArrayDynamic;
export declare function isABIConstraintStruct(c: ABIConstraint): c is IABIConstraintStruct;
export declare function runFixtureFn<T>(fn: () => Promise<T>): Promise<[T, BlockWithIndex[], SnapshotRestorer]>;
export declare function cartesianProduct<T>(arr: T[][]): T[][];
export declare function normalizeSequences<T>(sequences?: Sequences<T> | void): NormalizedSequences<T>;
export declare function takeSnapshot(): Promise<SnapshotRestorer>;
export declare class SnapshotRestorer {
    private snapshot;
    constructor(snapshot: string);
    restore(): Promise<void>;
}
export declare function isEthersAccount(address: any): address is Addressable;
export declare function isArray<T>(a: any): a is Array<T>;
export declare function extractAddress(address: AddressLike): Promise<string>;
//# sourceMappingURL=index.d.ts.map