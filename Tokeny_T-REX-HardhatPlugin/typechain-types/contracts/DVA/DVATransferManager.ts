/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../common";

export declare namespace IDVATransferManager {
  export type SignatureStruct = {
    v: PromiseOrValue<BigNumberish>;
    r: PromiseOrValue<BytesLike>;
    s: PromiseOrValue<BytesLike>;
  };

  export type SignatureStructOutput = [number, string, string] & {
    v: number;
    r: string;
    s: string;
  };

  export type ApprovalCriteriaStruct = {
    includeRecipientApprover: PromiseOrValue<boolean>;
    includeAgentApprover: PromiseOrValue<boolean>;
    sequentialApproval: PromiseOrValue<boolean>;
    additionalApprovers: PromiseOrValue<string>[];
    hash: PromiseOrValue<BytesLike>;
  };

  export type ApprovalCriteriaStructOutput = [
    boolean,
    boolean,
    boolean,
    string[],
    string
  ] & {
    includeRecipientApprover: boolean;
    includeAgentApprover: boolean;
    sequentialApproval: boolean;
    additionalApprovers: string[];
    hash: string;
  };

  export type ApproverStruct = {
    wallet: PromiseOrValue<string>;
    anyTokenAgent: PromiseOrValue<boolean>;
    approved: PromiseOrValue<boolean>;
  };

  export type ApproverStructOutput = [string, boolean, boolean] & {
    wallet: string;
    anyTokenAgent: boolean;
    approved: boolean;
  };

  export type TransferStruct = {
    tokenAddress: PromiseOrValue<string>;
    sender: PromiseOrValue<string>;
    recipient: PromiseOrValue<string>;
    amount: PromiseOrValue<BigNumberish>;
    status: PromiseOrValue<BigNumberish>;
    approvers: IDVATransferManager.ApproverStruct[];
    approvalCriteriaHash: PromiseOrValue<BytesLike>;
  };

  export type TransferStructOutput = [
    string,
    string,
    string,
    BigNumber,
    number,
    IDVATransferManager.ApproverStructOutput[],
    string
  ] & {
    tokenAddress: string;
    sender: string;
    recipient: string;
    amount: BigNumber;
    status: number;
    approvers: IDVATransferManager.ApproverStructOutput[];
    approvalCriteriaHash: string;
  };
}

export interface DVATransferManagerInterface extends utils.Interface {
  functions: {
    "approveTransfer(bytes32)": FunctionFragment;
    "calculateTransferID(uint256,address,address,uint256)": FunctionFragment;
    "cancelTransfer(bytes32)": FunctionFragment;
    "delegateApproveTransfer(bytes32,(uint8,bytes32,bytes32)[])": FunctionFragment;
    "getApprovalCriteria(address)": FunctionFragment;
    "getNextApprover(bytes32)": FunctionFragment;
    "getNextTxNonce()": FunctionFragment;
    "getTransfer(bytes32)": FunctionFragment;
    "initiateTransfer(address,address,uint256)": FunctionFragment;
    "name()": FunctionFragment;
    "rejectTransfer(bytes32)": FunctionFragment;
    "setApprovalCriteria(address,bool,bool,bool,address[])": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "approveTransfer"
      | "calculateTransferID"
      | "cancelTransfer"
      | "delegateApproveTransfer"
      | "getApprovalCriteria"
      | "getNextApprover"
      | "getNextTxNonce"
      | "getTransfer"
      | "initiateTransfer"
      | "name"
      | "rejectTransfer"
      | "setApprovalCriteria"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "approveTransfer",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "calculateTransferID",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelTransfer",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "delegateApproveTransfer",
    values: [PromiseOrValue<BytesLike>, IDVATransferManager.SignatureStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "getApprovalCriteria",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getNextApprover",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "getNextTxNonce",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getTransfer",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "initiateTransfer",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(functionFragment: "name", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "rejectTransfer",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "setApprovalCriteria",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<boolean>,
      PromiseOrValue<boolean>,
      PromiseOrValue<string>[]
    ]
  ): string;

  decodeFunctionResult(
    functionFragment: "approveTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculateTransferID",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "delegateApproveTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getApprovalCriteria",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNextApprover",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNextTxNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initiateTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "rejectTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setApprovalCriteria",
    data: BytesLike
  ): Result;

  events: {
    "ApprovalCriteriaSet(address,bool,bool,bool,address[],bytes32)": EventFragment;
    "TransferApprovalStateReset(bytes32,bytes32)": EventFragment;
    "TransferApproved(bytes32,address)": EventFragment;
    "TransferCancelled(bytes32)": EventFragment;
    "TransferCompleted(bytes32,address,address,address,uint256)": EventFragment;
    "TransferInitiated(bytes32,address,address,address,uint256,bytes32)": EventFragment;
    "TransferRejected(bytes32,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ApprovalCriteriaSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransferApprovalStateReset"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransferApproved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransferCancelled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransferCompleted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransferInitiated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransferRejected"): EventFragment;
}

export interface ApprovalCriteriaSetEventObject {
  tokenAddress: string;
  includeRecipientApprover: boolean;
  includeAgentApprover: boolean;
  sequentialApproval: boolean;
  additionalApprovers: string[];
  hash: string;
}
export type ApprovalCriteriaSetEvent = TypedEvent<
  [string, boolean, boolean, boolean, string[], string],
  ApprovalCriteriaSetEventObject
>;

export type ApprovalCriteriaSetEventFilter =
  TypedEventFilter<ApprovalCriteriaSetEvent>;

export interface TransferApprovalStateResetEventObject {
  transferID: string;
  approvalCriteriaHash: string;
}
export type TransferApprovalStateResetEvent = TypedEvent<
  [string, string],
  TransferApprovalStateResetEventObject
>;

export type TransferApprovalStateResetEventFilter =
  TypedEventFilter<TransferApprovalStateResetEvent>;

export interface TransferApprovedEventObject {
  transferID: string;
  approver: string;
}
export type TransferApprovedEvent = TypedEvent<
  [string, string],
  TransferApprovedEventObject
>;

export type TransferApprovedEventFilter =
  TypedEventFilter<TransferApprovedEvent>;

export interface TransferCancelledEventObject {
  transferID: string;
}
export type TransferCancelledEvent = TypedEvent<
  [string],
  TransferCancelledEventObject
>;

export type TransferCancelledEventFilter =
  TypedEventFilter<TransferCancelledEvent>;

export interface TransferCompletedEventObject {
  transferID: string;
  tokenAddress: string;
  sender: string;
  recipient: string;
  amount: BigNumber;
}
export type TransferCompletedEvent = TypedEvent<
  [string, string, string, string, BigNumber],
  TransferCompletedEventObject
>;

export type TransferCompletedEventFilter =
  TypedEventFilter<TransferCompletedEvent>;

export interface TransferInitiatedEventObject {
  transferID: string;
  tokenAddress: string;
  sender: string;
  recipient: string;
  amount: BigNumber;
  approvalCriteriaHash: string;
}
export type TransferInitiatedEvent = TypedEvent<
  [string, string, string, string, BigNumber, string],
  TransferInitiatedEventObject
>;

export type TransferInitiatedEventFilter =
  TypedEventFilter<TransferInitiatedEvent>;

export interface TransferRejectedEventObject {
  transferID: string;
  rejectedBy: string;
}
export type TransferRejectedEvent = TypedEvent<
  [string, string],
  TransferRejectedEventObject
>;

export type TransferRejectedEventFilter =
  TypedEventFilter<TransferRejectedEvent>;

export interface DVATransferManager extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: DVATransferManagerInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    approveTransfer(
      transferID: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    calculateTransferID(
      _nonce: PromiseOrValue<BigNumberish>,
      _sender: PromiseOrValue<string>,
      _recipient: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    cancelTransfer(
      transferID: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    delegateApproveTransfer(
      transferID: PromiseOrValue<BytesLike>,
      signatures: IDVATransferManager.SignatureStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getApprovalCriteria(
      tokenAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[IDVATransferManager.ApprovalCriteriaStructOutput]>;

    getNextApprover(
      transferID: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [string, boolean] & { nextApprover: string; anyTokenAgent: boolean }
    >;

    getNextTxNonce(overrides?: CallOverrides): Promise<[BigNumber]>;

    getTransfer(
      transferID: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[IDVATransferManager.TransferStructOutput]>;

    initiateTransfer(
      tokenAddress: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    name(overrides?: CallOverrides): Promise<[string] & { _name: string }>;

    rejectTransfer(
      transferID: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setApprovalCriteria(
      tokenAddress: PromiseOrValue<string>,
      includeRecipientApprover: PromiseOrValue<boolean>,
      includeAgentApprover: PromiseOrValue<boolean>,
      sequentialApproval: PromiseOrValue<boolean>,
      additionalApprovers: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  approveTransfer(
    transferID: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  calculateTransferID(
    _nonce: PromiseOrValue<BigNumberish>,
    _sender: PromiseOrValue<string>,
    _recipient: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  cancelTransfer(
    transferID: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  delegateApproveTransfer(
    transferID: PromiseOrValue<BytesLike>,
    signatures: IDVATransferManager.SignatureStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getApprovalCriteria(
    tokenAddress: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<IDVATransferManager.ApprovalCriteriaStructOutput>;

  getNextApprover(
    transferID: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<
    [string, boolean] & { nextApprover: string; anyTokenAgent: boolean }
  >;

  getNextTxNonce(overrides?: CallOverrides): Promise<BigNumber>;

  getTransfer(
    transferID: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<IDVATransferManager.TransferStructOutput>;

  initiateTransfer(
    tokenAddress: PromiseOrValue<string>,
    recipient: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  name(overrides?: CallOverrides): Promise<string>;

  rejectTransfer(
    transferID: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setApprovalCriteria(
    tokenAddress: PromiseOrValue<string>,
    includeRecipientApprover: PromiseOrValue<boolean>,
    includeAgentApprover: PromiseOrValue<boolean>,
    sequentialApproval: PromiseOrValue<boolean>,
    additionalApprovers: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    approveTransfer(
      transferID: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    calculateTransferID(
      _nonce: PromiseOrValue<BigNumberish>,
      _sender: PromiseOrValue<string>,
      _recipient: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    cancelTransfer(
      transferID: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    delegateApproveTransfer(
      transferID: PromiseOrValue<BytesLike>,
      signatures: IDVATransferManager.SignatureStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    getApprovalCriteria(
      tokenAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<IDVATransferManager.ApprovalCriteriaStructOutput>;

    getNextApprover(
      transferID: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [string, boolean] & { nextApprover: string; anyTokenAgent: boolean }
    >;

    getNextTxNonce(overrides?: CallOverrides): Promise<BigNumber>;

    getTransfer(
      transferID: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<IDVATransferManager.TransferStructOutput>;

    initiateTransfer(
      tokenAddress: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    name(overrides?: CallOverrides): Promise<string>;

    rejectTransfer(
      transferID: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    setApprovalCriteria(
      tokenAddress: PromiseOrValue<string>,
      includeRecipientApprover: PromiseOrValue<boolean>,
      includeAgentApprover: PromiseOrValue<boolean>,
      sequentialApproval: PromiseOrValue<boolean>,
      additionalApprovers: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "ApprovalCriteriaSet(address,bool,bool,bool,address[],bytes32)"(
      tokenAddress?: null,
      includeRecipientApprover?: null,
      includeAgentApprover?: null,
      sequentialApproval?: null,
      additionalApprovers?: null,
      hash?: null
    ): ApprovalCriteriaSetEventFilter;
    ApprovalCriteriaSet(
      tokenAddress?: null,
      includeRecipientApprover?: null,
      includeAgentApprover?: null,
      sequentialApproval?: null,
      additionalApprovers?: null,
      hash?: null
    ): ApprovalCriteriaSetEventFilter;

    "TransferApprovalStateReset(bytes32,bytes32)"(
      transferID?: null,
      approvalCriteriaHash?: null
    ): TransferApprovalStateResetEventFilter;
    TransferApprovalStateReset(
      transferID?: null,
      approvalCriteriaHash?: null
    ): TransferApprovalStateResetEventFilter;

    "TransferApproved(bytes32,address)"(
      transferID?: null,
      approver?: null
    ): TransferApprovedEventFilter;
    TransferApproved(
      transferID?: null,
      approver?: null
    ): TransferApprovedEventFilter;

    "TransferCancelled(bytes32)"(
      transferID?: null
    ): TransferCancelledEventFilter;
    TransferCancelled(transferID?: null): TransferCancelledEventFilter;

    "TransferCompleted(bytes32,address,address,address,uint256)"(
      transferID?: null,
      tokenAddress?: null,
      sender?: null,
      recipient?: null,
      amount?: null
    ): TransferCompletedEventFilter;
    TransferCompleted(
      transferID?: null,
      tokenAddress?: null,
      sender?: null,
      recipient?: null,
      amount?: null
    ): TransferCompletedEventFilter;

    "TransferInitiated(bytes32,address,address,address,uint256,bytes32)"(
      transferID?: null,
      tokenAddress?: null,
      sender?: null,
      recipient?: null,
      amount?: null,
      approvalCriteriaHash?: null
    ): TransferInitiatedEventFilter;
    TransferInitiated(
      transferID?: null,
      tokenAddress?: null,
      sender?: null,
      recipient?: null,
      amount?: null,
      approvalCriteriaHash?: null
    ): TransferInitiatedEventFilter;

    "TransferRejected(bytes32,address)"(
      transferID?: null,
      rejectedBy?: null
    ): TransferRejectedEventFilter;
    TransferRejected(
      transferID?: null,
      rejectedBy?: null
    ): TransferRejectedEventFilter;
  };

  estimateGas: {
    approveTransfer(
      transferID: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    calculateTransferID(
      _nonce: PromiseOrValue<BigNumberish>,
      _sender: PromiseOrValue<string>,
      _recipient: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    cancelTransfer(
      transferID: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    delegateApproveTransfer(
      transferID: PromiseOrValue<BytesLike>,
      signatures: IDVATransferManager.SignatureStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getApprovalCriteria(
      tokenAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNextApprover(
      transferID: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNextTxNonce(overrides?: CallOverrides): Promise<BigNumber>;

    getTransfer(
      transferID: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initiateTransfer(
      tokenAddress: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<BigNumber>;

    rejectTransfer(
      transferID: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setApprovalCriteria(
      tokenAddress: PromiseOrValue<string>,
      includeRecipientApprover: PromiseOrValue<boolean>,
      includeAgentApprover: PromiseOrValue<boolean>,
      sequentialApproval: PromiseOrValue<boolean>,
      additionalApprovers: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    approveTransfer(
      transferID: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    calculateTransferID(
      _nonce: PromiseOrValue<BigNumberish>,
      _sender: PromiseOrValue<string>,
      _recipient: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    cancelTransfer(
      transferID: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    delegateApproveTransfer(
      transferID: PromiseOrValue<BytesLike>,
      signatures: IDVATransferManager.SignatureStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getApprovalCriteria(
      tokenAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNextApprover(
      transferID: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNextTxNonce(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getTransfer(
      transferID: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initiateTransfer(
      tokenAddress: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rejectTransfer(
      transferID: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setApprovalCriteria(
      tokenAddress: PromiseOrValue<string>,
      includeRecipientApprover: PromiseOrValue<boolean>,
      includeAgentApprover: PromiseOrValue<boolean>,
      sequentialApproval: PromiseOrValue<boolean>,
      additionalApprovers: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
