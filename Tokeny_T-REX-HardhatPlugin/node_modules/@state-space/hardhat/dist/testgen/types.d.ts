export interface Addressable {
    getAddress(): Promise<string>;
}
export type AddressLike = string | Promise<string> | Addressable;
export type BlockTransaction = {
    transaction: TransactionWithIndex;
    number: string;
    timestamp: string;
    index: number;
};
export type BlockWithIndex = Block<TransactionWithIndex> & {
    index: number;
};
export type Block<Tx = Transaction> = {
    coinbase: string;
    difficulty: string;
    gasLimit: string;
    number: string;
    timestamp: string;
    baseFeePerGas: string;
    chainId: string;
    revision: string;
    transactions: Tx[];
};
export type TransactionWithIndex = Transaction & {
    index: number;
};
export type Transaction = {
    blockNumber: string;
    hash: string;
    index: number;
    input: string;
    value: string;
    from: string;
    to: string;
    nonce: string;
    gas: string;
    type: string;
    accessList: AccessList;
    chainId: string;
    gasPrice: string;
    maxFeePerGas: string;
    maxPriorityFeePerGas: string;
};
export type AccessList = Array<{
    address: string;
    storageKeys: Array<string>;
}>;
export type EIP1193Provider = {
    request(arg: {
        method: string;
        params: any[] | undefined;
    }): Promise<unknown>;
};
export type TxOverrides = {
    from?: string;
    value?: string;
};
export type SolcOutput = {
    _format?: string;
    solcVersion?: string;
    solcLongVersion?: string;
    input: {};
    output: {
        errors: {
            formattedMessage: string;
            type: string;
        }[];
        contracts: {
            [sourceName: string]: {
                [contractName: string]: {
                    abi?: any;
                    storageLayout?: any;
                };
            };
        };
        sources: {
            [sourceName: string]: {
                ast: {};
            };
        };
    };
};
export declare class TestGenAuthRetryError extends Error {
}
export declare class TestGenError extends Error {
}
export declare class TestGenFixtureError extends Error {
    testSetName: string;
    sourceError: Error;
    constructor(testSetName: string, sourceError: Error);
}
export type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
type InputMaybe<T> = T | undefined;
export type AddExplorerRequestInput = {
    compilationInputs?: InputMaybe<SolcCompilationInputRef>;
    compilationResults: Array<SolcCompilationResultRef>;
    config: ExplorerConfigRef;
    createdDt: Scalars["DateTime"];
    deployments: Array<EvmDeploymentRef>;
    project: ProjectRef;
    sequences: Array<SequenceSetRef>;
    status: RequestStatus | `${RequestStatus}`;
    switches?: InputMaybe<Scalars["String"]>;
    type: string;
    unmanaged: Scalars["Boolean"];
};
export declare enum RequestStatus {
    Completed = "Completed",
    Config = "Config",
    Created = "Created",
    Pending = "Pending",
    Post = "Post",
    Processed = "Processed",
    Started = "Started",
    Waiting = "Waiting"
}
export type ExplorerConfigRef = {
    autorun?: InputMaybe<Scalars["Boolean"]>;
    force?: InputMaybe<Scalars["Boolean"]>;
    id?: InputMaybe<Scalars["ID"]>;
    parameters?: InputMaybe<Scalars["String"]>;
    solcConfig?: InputMaybe<SolcCompilationConfigRef>;
};
export type EvmDeploymentRef = {
    accountNames?: InputMaybe<Array<AccountNameOverrideRef>>;
    blocks?: InputMaybe<Array<EthBlockRef>>;
    initialAccounts?: InputMaybe<Array<EthAccountRef>>;
    name?: InputMaybe<Scalars["String"]>;
    networkConfig?: InputMaybe<TestGenNetworkConfigRef>;
    sequences?: InputMaybe<Array<SequenceSetRef>>;
};
type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    /**
     * The DateTime scalar type represents date and time as a string in RFC3339 format.
     * For example: "1985-04-12T23:20:50.52Z" represents 20 mins 50.52 secs after the 23rd hour of Apr 12th 1985 in UTC.
     */
    DateTime: any;
    /**
     * The Int64 scalar type represents a signed 64‐bit numeric non‐fractional value.
     * Int64 can represent values in range [-(2^63),(2^63 - 1)].
     */
    Int64: any;
};
type AccountNameOverrideRef = {
    address?: InputMaybe<Scalars["String"]>;
    id?: InputMaybe<Scalars["ID"]>;
    name?: InputMaybe<Scalars["String"]>;
};
type EthAccountRef = {
    address?: InputMaybe<Scalars["String"]>;
    id?: InputMaybe<Scalars["ID"]>;
    index?: InputMaybe<Scalars["Int"]>;
};
type EthBlockRef = {
    id?: InputMaybe<Scalars["ID"]>;
    index?: InputMaybe<Scalars["Int"]>;
    number?: InputMaybe<Scalars["String"]>;
    timestamp?: InputMaybe<Scalars["String"]>;
    transactions?: InputMaybe<Array<EthTransactionRef>>;
};
type ProjectRef = {
    name?: InputMaybe<Scalars["String"]>;
};
type SequenceSetRef = {
    deployment?: InputMaybe<EvmDeploymentRef>;
    id?: InputMaybe<Scalars["ID"]>;
    name?: InputMaybe<Scalars["String"]>;
    sequences?: InputMaybe<Array<TestGenSequenceRef>>;
    sets?: InputMaybe<Array<SequenceSetRef>>;
};
type SolcCompilationConfigRef = {
    contractInclusionGlobsCore?: InputMaybe<Array<Scalars["String"]>>;
    contractInclusionGlobsIgnore?: InputMaybe<Array<Scalars["String"]>>;
    contractInclusionGlobsSupport?: InputMaybe<Array<Scalars["String"]>>;
    id?: InputMaybe<Scalars["ID"]>;
};
type SolcCompilationInputRef = {
    id?: InputMaybe<Scalars["ID"]>;
    solcInputs?: InputMaybe<Array<Scalars["String"]>>;
    solcVersions?: InputMaybe<Array<Scalars["String"]>>;
};
type SolcCompilationResultRef = {
    errors?: InputMaybe<Array<Scalars["String"]>>;
    id?: InputMaybe<Scalars["ID"]>;
    inputJson?: InputMaybe<Scalars["String"]>;
    onlyIncludePaths?: InputMaybe<Array<Scalars["String"]>>;
    outputJson?: InputMaybe<Scalars["String"]>;
    solcLongVersion?: InputMaybe<Scalars["String"]>;
    solcVersion?: InputMaybe<Scalars["String"]>;
};
type TestGenNetworkConfigRef = {
    blockGasLimit?: InputMaybe<Scalars["String"]>;
    chainId?: InputMaybe<Scalars["String"]>;
    coinbase?: InputMaybe<Scalars["String"]>;
    forking?: InputMaybe<ForkingConfigRef>;
    hardfork?: InputMaybe<Scalars["String"]>;
    id?: InputMaybe<Scalars["ID"]>;
    initialDate?: InputMaybe<Scalars["Int"]>;
};
export type TestGenSequenceRef = {
    depths?: InputMaybe<Array<TestGenSequenceDepthRef>>;
    id?: InputMaybe<Scalars["ID"]>;
    index?: InputMaybe<Scalars["Int"]>;
    name?: InputMaybe<Scalars["String"]>;
    sortKey?: InputMaybe<Scalars["String"]>;
};
export type TestGenSequenceDepthRef = {
    depth?: InputMaybe<Scalars["Int"]>;
    id?: InputMaybe<Scalars["ID"]>;
    tx?: InputMaybe<TestGenSequenceTxRef>;
};
export type TestGenSequenceTxRef = {
    ethBlockTransactionRef?: InputMaybe<EthBlockTransactionRef>;
    symtxRef?: InputMaybe<SymtxRef>;
};
export type EthBlockTransactionRef = {
    id?: InputMaybe<Scalars["ID"]>;
    index?: InputMaybe<Scalars["Int"]>;
    number?: InputMaybe<Scalars["String"]>;
    timestamp?: InputMaybe<Scalars["String"]>;
    transaction?: InputMaybe<EthTransactionRef>;
};
export type SymtxRef = {
    blockNumber?: InputMaybe<Scalars["String"]>;
    blockTimestamp?: InputMaybe<Scalars["String"]>;
    data?: InputMaybe<SymtxDataRef>;
    from?: InputMaybe<Scalars["String"]>;
    id?: InputMaybe<Scalars["ID"]>;
    to?: InputMaybe<Scalars["String"]>;
    value?: InputMaybe<Scalars["String"]>;
};
export type SymtxDataRef = {
    symtxDataCallRef?: InputMaybe<SymtxDataCallRef>;
    symtxDataRawRef?: InputMaybe<SymtxDataRawRef>;
};
export type SymtxDataRawRef = {
    data?: InputMaybe<Scalars["String"]>;
    id?: InputMaybe<Scalars["ID"]>;
};
export type SymtxDataCallRef = {
    args?: InputMaybe<Scalars["String"]>;
    contractKey?: InputMaybe<Scalars["String"]>;
    id?: InputMaybe<Scalars["ID"]>;
    signature?: InputMaybe<Scalars["String"]>;
};
export type EthTransactionRef = {
    from?: InputMaybe<Scalars["String"]>;
    id?: InputMaybe<Scalars["ID"]>;
    index?: InputMaybe<Scalars["Int"]>;
    input?: InputMaybe<Scalars["String"]>;
    to?: InputMaybe<Scalars["String"]>;
    value?: InputMaybe<Scalars["String"]>;
};
export type ForkingConfigRef = {
    blockNumber?: InputMaybe<Scalars["Int"]>;
    id?: InputMaybe<Scalars["ID"]>;
    network?: InputMaybe<Network | `${Network}`>;
    url?: InputMaybe<Scalars["String"]>;
};
export declare enum Network {
    Mainnet = "Mainnet",
    StateSpace = "StateSpace"
}
export {};
//# sourceMappingURL=types.d.ts.map