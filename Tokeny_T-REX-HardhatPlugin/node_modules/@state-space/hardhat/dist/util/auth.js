"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.authenticate = authenticate;
exports.loadCredentials = loadCredentials;
exports.saveCredentials = saveCredentials;
exports.clearCredentials = clearCredentials;
exports.parseJwt = parseJwt;
const fs_1 = require("fs");
const path = __importStar(require("path"));
const env_paths_1 = __importDefault(require("env-paths"));
const fs = __importStar(require("fs/promises"));
const config_1 = require("../config");
const retry_1 = require("./retry");
async function authenticate(spinner) {
    if (process.env.STATESPACE_USERNAME && process.env.STATESPACE_PASSWORD) {
        return await passwordFlow(process.env.STATESPACE_USERNAME, process.env.STATESPACE_PASSWORD, spinner);
    }
    else {
        return await deviceFlow(spinner);
    }
}
async function deviceFlow(spinner) {
    const refreshTokenCreds = await refreshToken(spinner);
    if (refreshTokenCreds) {
        return refreshTokenCreds;
    }
    const { url, code, interval } = await getLoginLink(spinner);
    const loginText = `Please login at ${url}`;
    while (true) {
        const creds = await pollLoginLink(code, loginText, spinner);
        if (!creds) {
            await new Promise((res) => setTimeout(res, interval * 1000));
            continue;
        }
        return creds;
    }
}
// Implements the device flow described at this link:
// https://auth0.com/docs/get-started/authentication-and-authorization-flow/call-your-api-using-the-device-authorization-flow
async function getLoginLink(spinner) {
    const data = await (0, retry_1.retryNetworkErrors)(() => fetch(`https://${(0, config_1.appConfig)()["auth0.domain"]}/oauth/device/code`, {
        method: "POST",
        headers: { "content-type": "application/x-www-form-urlencoded" },
        body: new URLSearchParams({
            client_id: (0, config_1.appConfig)()["auth0.clientId"],
            scope: "read:messages offline_access",
            audience: (0, config_1.appConfig)()["auth0.audience"],
        }),
    }).then(async (resp) => {
        if (!resp.ok) {
            throw new Error(await resp.text());
        }
        return resp.json();
    }), spinner);
    return {
        url: data["verification_uri_complete"],
        code: data["device_code"],
        interval: data["interval"],
    };
}
async function pollLoginLink(code, loginText, spinner) {
    return await (0, retry_1.retryNetworkErrors)(async () => {
        spinner.color = "white";
        spinner.text = loginText;
        return await fetch(`https://${(0, config_1.appConfig)()["auth0.domain"]}/oauth/token`, {
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
            body: new URLSearchParams({
                grant_type: "urn:ietf:params:oauth:grant-type:device_code",
                device_code: code,
                client_id: (0, config_1.appConfig)()["auth0.clientId"],
                scope: "offline_access",
            }),
            signal: AbortSignal.timeout(5000),
        }).then(async (resp) => {
            if (resp.status >= 400 && resp.status < 500) {
                return;
            }
            if (!resp.ok) {
                throw new Error(await resp.text());
            }
            const body = await resp.json();
            return {
                accessToken: body["access_token"],
                refreshToken: body["refresh_token"],
            };
        });
    }, spinner);
}
async function refreshToken(spinner) {
    const existingCreds = await loadCredentials();
    if (!existingCreds?.refreshToken) {
        return;
    }
    const tokenResp = await (0, retry_1.retryNetworkErrors)(async () => await fetch(`https://${(0, config_1.appConfig)()["auth0.domain"]}/oauth/token`, {
        method: "POST",
        headers: { "content-type": "application/x-www-form-urlencoded" },
        body: new URLSearchParams({
            grant_type: "refresh_token",
            client_id: (0, config_1.appConfig)()["auth0.clientId"],
            refresh_token: existingCreds.refreshToken,
        }),
        signal: AbortSignal.timeout(5000),
    }), spinner);
    if (tokenResp.ok) {
        const body = await tokenResp.json();
        return {
            accessToken: body["access_token"],
            refreshToken: body["refresh_token"],
        };
    }
}
async function passwordFlow(username, password, spinner) {
    const tokenResp = await (0, retry_1.retryNetworkErrors)(() => fetch(`https://${(0, config_1.appConfig)()["auth0.domain"]}/oauth/token`, {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: new URLSearchParams({
            grant_type: "password",
            client_id: (0, config_1.appConfig)()["auth0.clientId"],
            username,
            password,
            scope: "read:messages",
            audience: (0, config_1.appConfig)()["auth0.audience"],
        }),
    }).then((r) => r.json()), spinner);
    return {
        accessToken: tokenResp.data["access_token"],
        refreshToken: tokenResp.data["refresh_token"],
    };
}
//export async function auth(clear: boolean = false): Promise<Credentials> {
//  let creds = await loadCredentials()
//  if (!creds || clear) {
//    creds = await login()
//    if (!creds) {
//      throw new Error(`failed to authenticate`)
//    }
//    await saveCredentials(creds)
//  }
//
//  return creds
//}
async function loadCredentials() {
    const paths = (0, env_paths_1.default)("state-space", { suffix: "" });
    const credentialsFilePath = path.join(paths.cache, (0, config_1.appConfig)()["credentialsPath"]);
    try {
        await fs.access(credentialsFilePath, fs_1.constants.R_OK);
    }
    catch (_e) {
        return undefined;
    }
    const credentialsRaw = await fs.readFile(credentialsFilePath, "utf8");
    if (credentialsRaw) {
        return JSON.parse(credentialsRaw);
    }
}
async function saveCredentials(creds) {
    const paths = (0, env_paths_1.default)("state-space", { suffix: "" });
    const credentialsFilePath = path.join(paths.cache, (0, config_1.appConfig)()["credentialsPath"]);
    await fs.mkdir(paths.cache, { recursive: true });
    await fs.writeFile(credentialsFilePath, JSON.stringify(creds), {
        encoding: "utf8",
        mode: 0o600,
    });
}
async function clearCredentials() {
    const paths = (0, env_paths_1.default)("state-space", { suffix: "" });
    const credentialsFilePath = path.join(paths.cache, (0, config_1.appConfig)()["credentialsPath"]);
    await fs.mkdir(paths.cache, { recursive: true });
    await fs.unlink(credentialsFilePath).catch((err) => {
        if (err.code === "ENOENT") {
            return;
        }
        throw err;
    });
}
function parseJwt(token) {
    return JSON.parse(Buffer.from(token.split(".")[1], "base64").toString());
}
//# sourceMappingURL=auth.js.map