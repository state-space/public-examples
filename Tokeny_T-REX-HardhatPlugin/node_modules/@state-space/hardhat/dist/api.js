"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Api = void 0;
const node_path_1 = __importDefault(require("node:path"));
const node_zlib_1 = require("node:zlib");
const config_1 = require("./config");
const testgen_1 = require("./testgen");
const auth_1 = require("./util/auth");
const util_1 = require("./util/util");
class Api {
    config;
    auth;
    constructor(config) {
        this.config = config;
    }
    async init() {
        this.auth = await (0, auth_1.loadCredentials)();
        return this;
    }
    async requestExploration(autorun = true, force = false) {
        const hre = await Promise.resolve().then(() => __importStar(require("hardhat")));
        const sourceProvider = hre.network.provider;
        const provider = (0, testgen_1.normalizeProvider)(sourceProvider);
        const signers = (await provider.request({
            method: "eth_accounts",
            params: [],
        }));
        const networkConfig = {
            initialDate: hre.userConfig.networks?.hardhat?.initialDate
                ? Math.ceil(new Date(hre.config.networks.hardhat.initialDate || 0).getTime() / 1000)
                : undefined,
            chainId: `0x${hre.config.networks.hardhat.chainId.toString(16)}`,
            hardfork: hre.config.networks.hardhat.hardfork,
        };
        const initialAccounts = signers.map((address, i) => ({
            address: address,
            index: i,
            included: i < 3,
            code: "0x",
            balance: "0x021e19e0c9bab2400000",
        }));
        const deploymentRefs = [];
        for (const [name, deploymentFn] of Object.entries(this.config.deployments ?? {})) {
            if (!deploymentFn)
                continue;
            const deploymentRef = {
                name,
                initialAccounts,
                blocks: [],
                networkConfig,
                accountNames: [],
            };
            try {
                const [ret, blocks, preFixtureSnapshot] = await (0, testgen_1.runFixtureFn)(async () => deploymentFn(hre));
                deploymentRef.blocks = blocks
                    .filter(b => b.transactions.length)
                    .map(block => ({
                    transactions: block.transactions.map(transaction => ({
                        to: transaction.to,
                        from: transaction.from,
                        input: transaction.input,
                        value: transaction.value,
                        index: transaction.index,
                    })),
                    number: block.number,
                    timestamp: block.timestamp,
                    index: block.index,
                }));
                deploymentRef.accountNames = await Promise.all(Object.entries(ret?.accountNames ?? {})
                    .filter(([name, address]) => {
                    const warnings = [];
                    if (!name) {
                        warnings.push(`Account name for address ${address} must not be an empty string`);
                    }
                    switch (typeof address) {
                        case "string":
                            if (address.length != 42 || !address.startsWith("0x")) {
                                warnings.push(`Account name '${name}' address is invalid`);
                            }
                            break;
                        case "object":
                            if (address == null) {
                                warnings.push(`Account name '${name}' address cannot be null`);
                            }
                            if (!("getAddress" in address) && !("address" in address)) {
                                warnings.push(`Account name '${name}' address is invalid`);
                            }
                            break;
                        default:
                            warnings.push(`Account name '${name}' address is invalid`);
                    }
                    warnings.forEach(err => (0, util_1.warn)(`${err}, ignoring`));
                    return !warnings.length;
                })
                    .map(async ([name, address]) => {
                    return {
                        name,
                        address: (await (0, testgen_1.extractAddress)(address)).toLowerCase(),
                    };
                }));
                await preFixtureSnapshot.restore();
                deploymentRefs.push(deploymentRef);
            }
            catch (e) {
                throw new testgen_1.TestGenFixtureError(name, e);
            }
        }
        const solcOutputs = await (0, config_1.getSolcOutputs)();
        const srcPrefix = hre.config.paths.sources.replace(`${hre.config.paths.root}/`, "");
        const explorerConfig = {
            autorun,
            force,
            solcConfig: {
                contractInclusionGlobsCore: [`${srcPrefix}/**`],
                contractInclusionGlobsSupport: [],
                contractInclusionGlobsIgnore: [],
            },
            parameters: "{}",
        };
        if (!deploymentRefs.length) {
            deploymentRefs.push({
                name: this.config.project,
                sequences: [],
                blocks: [],
                initialAccounts,
                networkConfig,
            });
        }
        const request = {
            config: explorerConfig,
            compilationInputs: {},
            compilationResults: solcOutputs.map(o => {
                return {
                    solcVersion: o.solcVersion,
                    solcLongVersion: o.solcLongVersion,
                    inputJson: JSON.stringify(o.input),
                    outputJson: (0, node_zlib_1.gzipSync)(JSON.stringify(o.output), {}).toString("base64"),
                    errors: (o.output.errors ?? []).filter(e => e.type == "Error").map(e => e.formattedMessage),
                };
            }),
            deployments: deploymentRefs,
            sequences: [], // todo
            switches: process.env.STATESPACE_SWITCHES,
            project: { name: this.config.project },
            createdDt: new Date().toISOString(),
            unmanaged: false,
            status: "Waiting",
            type: "ExplorerRequestType",
        };
        if (process.env.DRY) {
            if (process.env.LOCAL) {
                console.dir(request, { depth: 4 });
            }
            return undefined;
        }
        await upsertProject(this.config.team, { input: { name: this.config.project } }, this.auth?.accessToken);
        return await requestExploration(this.config.team, { input: JSON.stringify(request) }, this.auth?.accessToken).then(res => res.explore);
    }
    async status(_id) { }
    async setAuth(creds) {
        this.auth = creds;
        await (0, auth_1.saveCredentials)(creds);
    }
}
exports.Api = Api;
async function requestExploration(team, vars, accessToken) {
    return request(team, {
        query: gql `
        mutation RequestExploration($input: String!) {
          explore(input: $input) {
            id
            error
            message
          }
        }`,
        variables: vars,
    }, accessToken);
}
async function upsertProject(team, vars, accessToken) {
    return request(team, {
        query: gql `
        mutation UpsertProject($input: AddProjectInput!) {
          addProject(input: [$input], upsert: true) {
            project {
              id
            }
          }
        }
      `,
        variables: vars,
    }, accessToken);
}
async function request(team, request, accessToken) {
    const response = await fetch(node_path_1.default.join((0, config_1.appConfig)().api, team), {
        method: "POST",
        headers: { "Authorization": `Bearer ${accessToken}`, "Content-Type": "application/json" },
        body: JSON.stringify(request),
    });
    let body = "";
    let data;
    try {
        body = await response.text();
        data = JSON.parse(body);
    }
    catch (e) {
        console.error("requestExploration: parsing body", e);
    }
    if (!response.ok) {
        if ([401, 403].includes(response.status)) {
            throw new testgen_1.TestGenAuthRetryError();
        }
        console.error("requestExploration: error:", response.status, body);
        throw new testgen_1.TestGenError("Failed to submit request");
    }
    if (!data) {
        throw new testgen_1.TestGenError("Failed to submit request");
    }
    if (data.errors) {
        throw new testgen_1.TestGenError("Failed to submit request: " + data.errors.map(e => e.message).join("\n"));
    }
    return data.data;
}
function gql(i) {
    return i.join("");
}
//# sourceMappingURL=api.js.map